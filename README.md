# DB-script

## Главное

### Описание

Скрипт который инициализирует БД+таблицу(команда 1) и генерирует значения туда(команда 4). При необходимости можно дропнуть БД(команда 0) для удобства тестирования.
Можно записывать свои строки в БД(команда 2) и делать вывод уникальных значений (команда 3). 
И самое главное можно выводить фильтрованные значения(по ТЗ нужно было хардкодить фамилии на F и мужчин) + оптимизировать запросы(команды 5 и 6 соответственно)  

### Запуск

Настройте свои данные для подключения к серверу СУБД в файле .env. Я разрабатывал на основе postgreSQL и не имею понятия заработает ли если подключаться к другой СУБД.

Находясь в репозитории проекта установите виртуальное окружение и зависимости в него:

```bash
python -m venv venv
.\venv\Scripts\activate  
pip install -r requirements.txt 
```

Пример запуска:

```bash
python script.py 1
```

### Результат оптимизации

В качестве средства оптимизации я решил использовать составные индексы. PostgreSQL при выполнении запросов анализирует имеющиеся индексы и сам выбирает эффективный индекс. Таким образом не меняя реализацию 5-ой комманды мы оптимизировали время выполнения запроса.
Объем по которому проводился поиск: "Total rows: 1000100"

```bash
PS C:\Users\Admin\Documents\GitHub\db-script> python statistic.py
Число выполнений: 100
Медиана: 0.08348941802978516
PS C:\Users\Admin\Documents\GitHub\db-script> python script.py 6
Составной индекс (gender, full_name) создан.
Execution time for run: 0:00:03.678742
PS C:\Users\Admin\Documents\GitHub\db-script> python statistic.py
Число выполнений: 100
Медиана: 0.07109522819519043
```

Как видно из вывода медианное время выполнения уменьшилось на ~15% после выполнения оптимизации.

## Допущения

### Комманда для удаления таблицы

Я добавил незаявленную комманду для удаления таблицы users как команду 0. Она была невероятно удобна при тестировке других комманд поэтому я, на всякий случай, оставил ее для "продакшена"

### Отчество = второе имя

ФИО в БД представляет собой запись вида: "Фамилия Имя Имя". Это обусловлено тем что нет эффективного способа генерации русского отчества на латинице. Аналогично с генерацией русских имен и фамилий на латинице.
Поэтому вместо патронима(отчества) я взял второе имя(middle name).
Я считаю это оправданным допущением потому что в реальной среде программа будет получать ФИО и валидировать его, не занимаясь его генерацией. Также не хотелось бы удваивать объем кода и времени выполнения ради не самой значимой информации.

### Уникальных записей слишком много

Поскольку генерация представляет собой комбинирование элементов массивов(векторов) то уникальных значений может получаться довольно много. Балансируя между равномерным распределением первой буквы фамилии и повышением числа неуникальных записей для тестирования 3 комманды я пришел к ~80% повторяющихся записей. Но все равно этих записей очень много, поэтому в отображении я использовал пагинацию. И красивое оформление tabulate
